# 前言
前后端分离以及模块化的开发方式，给前端提供了很多开发便利，大大提高了开发效率，降低了维护成本。

同时也带来了不利的一面。

前端引入的各种框架、功能模块以及保证代码正常运作的 polyfill 模块等，导致最终打包生成的文件大。

尤其对于单页面来说，请求体积过大，会导致白屏时间长，带来前端性能的降低。

# 概要
对于 Webpack 打包体积过大这个问题的解决方法，主要在三个方向：

一个是按需加载，思路是，将模块中不需要的代码剔除掉。

一个是拆包缓存，思路是，主要将代码分为经常变更（如业务代码）类以及不经常变更（如使用的框架、工具等），然后利用 CDN 或其他缓存方式进行缓存。

一个是动态加载，思路是，如果业务代码依旧很多，可以根据路由进行动态加载，减少第一次加载时业务代码的体积。

# 内容
## 按需加载
针对不同的模块，实现按需加载的方式也不同。

组件库类型（antd、element等）
这些主流组件库，都会提供按需加载的方式。

比如说对于 antd 组件库，官方提供了两种按需加载的方式

一种是通过 babel-plugin-import 插件实现，另一种是手动引入的方式

同理，element 组件库，官方也提供了按需加载的方式，通过babel-plugin-component实现

如图所示，按需加载和非按需加载打包出来的体积大小变化

工具库类型（moment、lodash、babel-polyfill等）
moment 提供了 webpack，去减少无用包的打包，以及其他用法

lodash 也提供了一些 babel 方式和 webpack 方式

babel-polyfill 的包比较大，暂时还没有找到一个很好的方案，尤其是升级到 7+ 版本以后，就是这个样子了

总之一句话，就是前端无论用到了什么包，就要记住按需加载。记得在官方文档上查看是否有按需加载

## 拆包缓存
如果经过按需加载之后，发现，你项目所需要的包还是很大。那么下一步，我们就需要把包分为两部分，一部分是不经常变动的比如框架、工具库之类，另外一部分就是业务代码包。

目前有三种方式可以实现

splitChunks（cacheGroups）
externals
dllPlugin
## 动态加载
React 单页面的动态加载
Vue 单页面的动态加载